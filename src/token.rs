use crate::{
    crypto,
    error::SelfError,
    keypair::{exchange, signing},
};

use serde::{Deserialize, Serialize};

const TOKEN_VERSION_1: u8 = 1;
const TOKEN_KIND_AUTHENTICATION: u8 = 1;
const TOKEN_KIND_SEND: u8 = 2;
const TOKEN_KIND_PUSH: u8 = 3;
const TOKEN_KIND_SUBSCRIPTION: u8 = 4;
const TOKEN_KIND_DELEGATION: u8 = 5;
const FLAG_DELEGATION_PERMIT: u8 = 1 << 1;
const FLAG_BEARER_PROMISCUOUS: u8 = 1 << 2;
const HEADER_LENGTH: usize = 1 + 1 + 4 + 20 + 8 + 8;
const AUTHENTICATION_BASE_LENGTH: usize = HEADER_LENGTH + 32 + 33 + 64;
const PUSH_BASE_LENGTH: usize = HEADER_LENGTH + 2 + 33 + 33 + 64;
const SEND_BASE_LENGTH: usize = HEADER_LENGTH + 33 + 64;
const SUBSCRIBE_BASE_LENGTH: usize = HEADER_LENGTH + 33 + 33 + 64;

#[derive(Clone, Serialize, Deserialize)]
pub enum Token {
    Authentication(Authentication),
    Push(Push),
    Send(Send),
    Subscription(Subscription),
    Delegation(Delegation),
}

impl Token {
    pub fn kind(&self) -> u8 {
        match self {
            Token::Authentication(_) => TOKEN_KIND_AUTHENTICATION,
            Token::Push(_) => TOKEN_KIND_PUSH,
            Token::Send(_) => TOKEN_KIND_SEND,
            Token::Subscription(_) => TOKEN_KIND_SUBSCRIPTION,
            Token::Delegation(_) => TOKEN_KIND_DELEGATION,
        }
    }

    pub fn decode(bytes: &[u8]) -> Result<Token, SelfError> {
        if bytes[0] != TOKEN_VERSION_1 {
            return Err(SelfError::TokenVersionInvalid);
        }

        // TODO proper token validation
        Ok(match bytes[1] {
            TOKEN_KIND_AUTHENTICATION => Token::Authentication(Authentication {
                token: bytes.to_vec(),
            }),
            TOKEN_KIND_SEND => Token::Send(Send {
                token: bytes.to_vec(),
            }),
            TOKEN_KIND_PUSH => Token::Push(Push {
                token: bytes.to_vec(),
            }),
            TOKEN_KIND_SUBSCRIPTION => Token::Subscription(Subscription {
                token: bytes.to_vec(),
            }),
            TOKEN_KIND_DELEGATION => Token::Delegation(Delegation {
                token: bytes.to_vec(),
            }),
            _ => return Err(SelfError::TokenTypeInvalid),
        })
    }

    pub fn encode(&self) -> Result<Vec<u8>, SelfError> {
        Ok(match self {
            Token::Authentication(auth) => auth.token.to_vec(),
            Token::Send(send) => send.token.to_vec(),
            Token::Push(push) => push.token.to_vec(),
            Token::Subscription(sub) => sub.token.to_vec(),
            Token::Delegation(del) => del.token.to_vec(),
        })
    }

    pub fn version(&self) -> u8 {
        match self {
            Token::Authentication(auth) => auth.token[0],
            Token::Send(send) => send.token[0],
            Token::Push(push) => push.token[0],
            Token::Subscription(sub) => sub.token[0],
            Token::Delegation(del) => del.token[0],
        }
    }

    pub fn id(&self) -> Vec<u8> {
        match self {
            Token::Authentication(auth) => auth.token[6..26].to_vec(),
            Token::Send(send) => send.token[6..26].to_vec(),
            Token::Push(push) => push.token[6..26].to_vec(),
            Token::Subscription(sub) => sub.token[6..26].to_vec(),
            Token::Delegation(del) => del.token[6..26].to_vec(),
        }
    }

    pub fn validate(&self) -> Result<(), SelfError> {
        match self {
            Token::Authentication(auth) => auth.validate(),
            Token::Send(send) => send.validate(),
            Token::Push(push) => push.validate(),
            Token::Subscription(sub) => sub.validate(),
            Token::Delegation(del) => del.validate(),
        }
    }
}

/// / Authentication generated by an identifier to authenticate an action it is performing,
/// / such as making an http or gRPC request. The authentication token includes a signature over arbitrary
/// / data that is included in the token as a hash
// | version | type | flags | nonce | issued | exipry | content hash | signer alg | signer | signature |
// | 1.  version (1 byte)
// | 2.  type (1 byte)
// | 3.  flag options (4 bytes)
// | 4.  nonce (20 bytes)
// | 5.  issued timestamp seconds (8 bytes)
// | 6.  expiry timestamp seconds (8 bytes)
// | 7.  content hash sha3 256 (32 bytes)
// | 9.  signer (33 bytes)
// | 10. signature over above fields (64 bytes)
#[derive(Clone, Serialize, Deserialize)]
pub struct Authentication {
    pub token: Vec<u8>,
}

impl Authentication {
    pub fn new(
        issued_by: &signing::KeyPair,
        issued: i64,
        expires: i64,
        content: &[u8],
    ) -> Authentication {
        let mut token = vec![0; 1 + 1 + 4 + 20 + 8 + 8 + 32 + 33 + 64];

        token[0] = TOKEN_VERSION_1;
        token[1] = TOKEN_KIND_AUTHENTICATION;
        // 2..6 reserved for flags
        crate::crypto::random::read_bytes(&mut token[6..26]);
        token[26..34].copy_from_slice(&issued.to_le_bytes());
        token[34..42].copy_from_slice(&expires.to_le_bytes());

        let content_hash = crypto::hash::sha3(content);

        token[42..74].copy_from_slice(&content_hash);
        token[74..107].copy_from_slice(issued_by.address());

        let signature = issued_by.sign(&token[0..107]);
        token[107..171].copy_from_slice(&signature);

        Authentication { token }
    }

    pub fn nonce(&self) -> &[u8] {
        &self.token[6..26]
    }

    pub fn issued(&self) -> i64 {
        i64::from_le_bytes(
            self.token[26..34]
                .try_into()
                .expect("invalid issued timestamp"),
        )
    }

    pub fn expires(&self) -> i64 {
        i64::from_le_bytes(
            self.token[34..42]
                .try_into()
                .expect("invalid expires timestamp"),
        )
    }

    pub fn issuer(&self) -> &[u8] {
        &self.token[74..107]
    }

    pub fn content_hash(&self) -> &[u8] {
        &self.token[42..74]
    }

    pub fn validate(&self) -> Result<(), SelfError> {
        // validate header size
        if self.token.len() < HEADER_LENGTH {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate timestamps
        let issued = match self.token[26..34].try_into() {
            Ok(issued) => i64::from_le_bytes(issued),
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        let expires = match self.token[34..42].try_into() {
            Ok(expires) => i64::from_le_bytes(expires),
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        if issued > expires {
            return Err(SelfError::TokenEncodingInvalid);
        }

        if self.token.len() != AUTHENTICATION_BASE_LENGTH {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate signer
        let signer = signing::PublicKey::from_bytes(&self.token[74..107])?;

        // validate signature
        if !signer.verify(&self.token[0..107], &self.token[107..171]) {
            return Err(SelfError::TokenSignatureInvalid);
        }

        Ok(())
    }

    pub fn to_vec(&self) -> Vec<u8> {
        self.token.to_vec()
    }

    pub fn as_bytes(&self) -> &[u8] {
        &self.token
    }
}

#[derive(Clone, Serialize, Deserialize)]
pub struct Delegation {
    pub token: Vec<u8>,
}

impl Delegation {
    pub fn signer(&self) -> signing::PublicKey {
        signing::PublicKey::from_bytes(&self.token[35..67]).expect("already validated public key")
    }

    pub fn validate(&self) -> Result<(), SelfError> {
        Ok(())
    }
}

/// / Push generated by an identifier to permit it's bearer to send push notifications.
/// / Can be resticted to use by a single identifier or by any identitfier
/// / that bears the token send token format and fields
/// / Can be delegated to another identifier
// | version | type | flags | nonce | issued | expiry | push len | push | exchange | bearer (optional) | signer | signature |
// | 1.  version (1 byte)
// | 2.  type (1 byte)
// | 3.  flag options (4 bytes)
// | 4.  nonce (20 bytes)
// | 5.  issued timestamp seconds (8 bytes)
// | 6.  expiry timestamp seconds (8 bytes)
// | 7.  push encrypted token length (2 bytes)
// | 8.  push encrypted token (? bytes)
// | 9.  exchange public key (33 bytes, alg + public key)
// | 7.  bearer (33 bytes, alg + public key, [optional, not required if FLAG_BEARER_PROMISCUOUS is set])
// | 8.  signer (33 bytes)
// | 9. signature over above fields (64 bytes)
#[derive(Clone, Serialize, Deserialize)]
pub struct Push {
    pub token: Vec<u8>,
}

impl Push {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        issued_by: &signing::KeyPair,
        intended_for: Option<&signing::PublicKey>,
        encrypted_for: &exchange::PublicKey,
        exchange_with: &exchange::PublicKey,
        issued: i64,
        expires: i64,
        delegatable: bool,
        push_credential: &[u8],
    ) -> Push {
        let mut options: i32 = 0;

        // encrypt this token for the push provider to decrypt
        let encrypted_push_credential = encrypted_for.seal_anonymous(push_credential);
        let epcl = encrypted_push_credential.len();

        if let Some(for_identifier) = intended_for {
            let mut token = vec![0; 1 + 1 + 4 + 20 + 8 + 8 + 2 + epcl + 33 + 33 + 33 + 64];

            if delegatable {
                options |= FLAG_DELEGATION_PERMIT as i32;
            }

            token[0] = TOKEN_VERSION_1;
            token[1] = TOKEN_KIND_PUSH;
            token[2..6].copy_from_slice(&options.to_le_bytes());
            crate::crypto::random::read_bytes(&mut token[6..26]);
            token[26..34].copy_from_slice(&issued.to_le_bytes());
            token[34..42].copy_from_slice(&expires.to_le_bytes());

            token[42..44].copy_from_slice(&(epcl as u16).to_le_bytes());
            token[44..44 + epcl].copy_from_slice(&encrypted_push_credential);

            token[44 + epcl..77 + epcl].copy_from_slice(exchange_with.address());
            token[77 + epcl..110 + epcl].copy_from_slice(for_identifier.address());
            token[110 + epcl..143 + epcl].copy_from_slice(issued_by.address());

            let signature = issued_by.sign(&token[0..143 + epcl]);
            token[143 + epcl..207 + epcl].copy_from_slice(&signature);

            Push { token }
        } else {
            let mut token = vec![0; 1 + 1 + 4 + 20 + 8 + 8 + 2 + epcl + 33 + 33 + 64];

            options |= FLAG_BEARER_PROMISCUOUS as i32;

            token[0] = TOKEN_VERSION_1;
            token[1] = TOKEN_KIND_PUSH;
            token[2..6].copy_from_slice(&options.to_le_bytes());
            crate::crypto::random::read_bytes(&mut token[6..26]);
            token[26..34].copy_from_slice(&issued.to_le_bytes());
            token[34..42].copy_from_slice(&expires.to_le_bytes());

            let epcl = encrypted_push_credential.len();

            token[42..44].copy_from_slice(&(epcl as u16).to_le_bytes());
            token[44..44 + epcl].copy_from_slice(&encrypted_push_credential);

            token[44 + epcl..77 + epcl].copy_from_slice(exchange_with.address());
            token[77 + epcl..110 + epcl].copy_from_slice(issued_by.address());

            let signature = issued_by.sign(&token[0..110 + epcl]);
            token[110 + epcl..174 + epcl].copy_from_slice(&signature);

            Push { token }
        }
    }

    pub fn nonce(&self) -> &[u8] {
        &self.token[6..26]
    }

    pub fn issued(&self) -> i64 {
        i64::from_le_bytes(
            self.token[26..34]
                .try_into()
                .expect("invalid issued timestamp"),
        )
    }

    pub fn expires(&self) -> i64 {
        i64::from_le_bytes(
            self.token[34..42]
                .try_into()
                .expect("invalid expires timestamp"),
        )
    }

    pub fn exchange(&self) -> &[u8] {
        let epcl =
            u16::from_le_bytes(self.token[42..44].try_into().expect("invalid flags")) as usize;
        &self.token[epcl + 44..epcl + 77]
    }

    pub fn issuer(&self) -> &[u8] {
        let options = i32::from_le_bytes(self.token[2..6].try_into().expect("invalid flags"));
        let epcl =
            u16::from_le_bytes(self.token[42..44].try_into().expect("invalid flags")) as usize;

        if options & (FLAG_BEARER_PROMISCUOUS as i32) != 0 {
            &self.token[77 + epcl..110 + epcl]
        } else {
            &self.token[110 + epcl..143 + epcl]
        }
    }

    pub fn bearer(&self) -> Option<&[u8]> {
        let options = i32::from_le_bytes(self.token[2..6].try_into().expect("invalid flags"));
        let epcl =
            u16::from_le_bytes(self.token[42..44].try_into().expect("invalid flags")) as usize;

        if options & (FLAG_BEARER_PROMISCUOUS as i32) != 0 {
            None
        } else {
            Some(&self.token[77 + epcl..110 + epcl])
        }
    }

    pub fn validate(&self) -> Result<(), SelfError> {
        // validate header size
        if self.token.len() < HEADER_LENGTH + 2 {
            return Err(SelfError::TokenEncodingInvalid);
        }

        let options = match self.token[2..6].try_into() {
            Ok(options) => i32::from_le_bytes(options),
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        // validate timestamps
        let issued = match self.token[26..34].try_into() {
            Ok(issued) => i64::from_le_bytes(issued),
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        let expires = match self.token[34..42].try_into() {
            Ok(expires) => i64::from_le_bytes(expires),
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        if issued > expires {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate length based on what flags are set
        if options & (FLAG_BEARER_PROMISCUOUS as i32) != 0 {
            self.validate_without_bearer()
        } else {
            self.validate_with_bearer()
        }
    }

    fn validate_with_bearer(&self) -> Result<(), SelfError> {
        let epcl = match self.token[42..44].try_into() {
            Ok(epcl) => u16::from_le_bytes(epcl) as usize,
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        if self.token.len() != PUSH_BASE_LENGTH + 33 + epcl {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate payload size
        if epcl > self.token.len() - (HEADER_LENGTH + 2 + 33 + 33 + 33 + 64) {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate exchange
        exchange::PublicKey::validate(&self.token[44 + epcl..77 + epcl])?;

        // validate bearer
        signing::PublicKey::validate(&self.token[77 + epcl..110 + epcl])?;

        // validate signer
        let signer = signing::PublicKey::from_bytes(&self.token[110 + epcl..143 + epcl])?;

        // validate signature
        if !signer.verify(
            &self.token[0..143 + epcl],
            &self.token[143 + epcl..207 + epcl],
        ) {
            return Err(SelfError::TokenSignatureInvalid);
        }

        Ok(())
    }

    fn validate_without_bearer(&self) -> Result<(), SelfError> {
        let epcl = match self.token[42..44].try_into() {
            Ok(epcl) => u16::from_le_bytes(epcl) as usize,
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        if self.token.len() != PUSH_BASE_LENGTH + epcl {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate payload size
        if epcl > self.token.len() - (HEADER_LENGTH + 2 + 33 + 33 + 64) {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate exchange
        exchange::PublicKey::validate(&self.token[44 + epcl..77 + epcl])?;

        // validate signer
        let signer = signing::PublicKey::from_bytes(&self.token[77 + epcl..110 + epcl])?;

        // validate signature
        if !signer.verify(
            &self.token[0..110 + epcl],
            &self.token[110 + epcl..174 + epcl],
        ) {
            return Err(SelfError::TokenSignatureInvalid);
        }

        Ok(())
    }

    pub fn to_vec(&self) -> Vec<u8> {
        self.token.to_vec()
    }

    pub fn as_bytes(&self) -> &[u8] {
        &self.token
    }
}

/// / Send generated by an identifier to permit it's bearer to send messages.
/// / Can be resticted to use by a single identifier or by any identitfier
/// / that bears the token send token format and fields
// | version | type | flags | nonce | issued | expiry | bearer (optional) | signer | signature |
// | 1.  version (1 byte)
// | 2.  type (1 byte)
// | 3.  flag options (4 bytes)
// | 4.  nonce (20 bytes)
// | 5.  issued timestamp seconds (8 bytes)
// | 6.  expiry timestamp seconds (8 bytes)
// | 7.  bearer (33 bytes, alg + public key, [optional, not required if FLAG_BEARER_PROMISCUOUS is set])
// | 8.  signer (33 bytes)
// | 9. signature over above fields (64 bytes)
#[derive(Clone, Serialize, Deserialize)]
pub struct Send {
    pub token: Vec<u8>,
}

impl Send {
    pub fn new(
        issued_by: &signing::KeyPair,
        intended_for: Option<&signing::PublicKey>,
        issued: i64,
        expires: i64,
    ) -> Send {
        if let Some(for_identifier) = intended_for {
            let mut token = vec![0; 1 + 1 + 4 + 20 + 8 + 8 + 33 + 33 + 64];

            token[0] = TOKEN_VERSION_1;
            token[1] = TOKEN_KIND_SEND;
            crate::crypto::random::read_bytes(&mut token[6..26]);
            token[26..34].copy_from_slice(&issued.to_le_bytes());
            token[34..42].copy_from_slice(&expires.to_le_bytes());
            token[42..75].copy_from_slice(for_identifier.address());
            token[75..108].copy_from_slice(issued_by.address());

            let signature = issued_by.sign(&token[0..108]);
            token[108..172].copy_from_slice(&signature);

            Send { token }
        } else {
            let mut token = vec![0; 1 + 1 + 4 + 20 + 8 + 8 + 33 + 64];

            let mut options: i32 = 0;
            options |= FLAG_BEARER_PROMISCUOUS as i32;

            token[0] = TOKEN_VERSION_1;
            token[1] = TOKEN_KIND_SEND;
            token[2..6].copy_from_slice(&options.to_le_bytes());
            crate::crypto::random::read_bytes(&mut token[6..26]);
            token[26..34].copy_from_slice(&issued.to_le_bytes());
            token[34..42].copy_from_slice(&expires.to_le_bytes());
            token[42..75].copy_from_slice(issued_by.address());
            let signature = issued_by.sign(&token[0..75]);
            token[75..139].copy_from_slice(&signature);

            Send { token }
        }
    }

    pub fn nonce(&self) -> &[u8] {
        &self.token[6..26]
    }

    pub fn issued(&self) -> i64 {
        i64::from_le_bytes(
            self.token[26..34]
                .try_into()
                .expect("invalid issued timestamp"),
        )
    }

    pub fn expires(&self) -> i64 {
        i64::from_le_bytes(
            self.token[34..42]
                .try_into()
                .expect("invalid expires timestamp"),
        )
    }

    pub fn issuer(&self) -> &[u8] {
        let options = i32::from_le_bytes(self.token[2..6].try_into().expect("invalid flags"));

        if options & (FLAG_BEARER_PROMISCUOUS as i32) != 0 {
            &self.token[42..75]
        } else {
            &self.token[75..108]
        }
    }

    pub fn bearer(&self) -> Option<&[u8]> {
        let options = i32::from_le_bytes(self.token[2..6].try_into().expect("invalid flags"));

        if options & (FLAG_BEARER_PROMISCUOUS as i32) != 0 {
            None
        } else {
            Some(&self.token[42..75])
        }
    }

    pub fn validate(&self) -> Result<(), SelfError> {
        // validate header size
        if self.token.len() < HEADER_LENGTH {
            return Err(SelfError::TokenEncodingInvalid);
        }

        let options = match self.token[2..6].try_into() {
            Ok(options) => i32::from_le_bytes(options),
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        // validate timestamps
        let issued = match self.token[26..34].try_into() {
            Ok(issued) => i64::from_le_bytes(issued),
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        let expires = match self.token[34..42].try_into() {
            Ok(expires) => i64::from_le_bytes(expires),
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        if issued > expires {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate length based on what flags are set
        if options & (FLAG_BEARER_PROMISCUOUS as i32) != 0 {
            self.validate_without_bearer()
        } else {
            self.validate_with_bearer()
        }
    }

    fn validate_with_bearer(&self) -> Result<(), SelfError> {
        if self.token.len() < SEND_BASE_LENGTH + 33 {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate bearer
        signing::PublicKey::validate(&self.token[42..75])?;

        // validate signer
        let signer = signing::PublicKey::from_bytes(&self.token[75..108])?;

        // validate signature
        if !signer.verify(&self.token[0..108], &self.token[108..172]) {
            return Err(SelfError::TokenSignatureInvalid);
        }

        Ok(())
    }

    fn validate_without_bearer(&self) -> Result<(), SelfError> {
        if self.token.len() < SEND_BASE_LENGTH {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate signer
        let signer = signing::PublicKey::from_bytes(&self.token[42..75])?;

        // validate signature
        if !signer.verify(&self.token[0..75], &self.token[75..139]) {
            return Err(SelfError::TokenSignatureInvalid);
        }

        Ok(())
    }

    pub fn to_vec(&self) -> Vec<u8> {
        self.token.to_vec()
    }

    pub fn as_bytes(&self) -> &[u8] {
        &self.token
    }
}

/// / Subscription generated by an identifier to permit it's bearer to subscribe to an inbox.
// | version | type | flags | nonce | issued | expiry | signer | signature |
// | 1.  version (1 byte)
// | 2.  type (1 byte)
// | 3.  flag options (4 bytes)
// | 4.  nonce (20 bytes)
// | 5.  issued timestamp seconds (8 bytes)
// | 6.  expiry timestamp seconds (8 bytes)
// | 9.  signer (33 bytes)
// | 10. signature over above fields (64 bytes)
#[derive(Clone, Serialize, Deserialize)]
pub struct Subscription {
    pub token: Vec<u8>,
}

impl Subscription {
    pub fn new(
        issued_by: &signing::KeyPair,
        intended_for: &signing::PublicKey,
        issued: i64,
        expires: i64,
    ) -> Subscription {
        let mut token = vec![0; 1 + 1 + 4 + 20 + 8 + 8 + 33 + 33 + 64];

        token[0] = TOKEN_VERSION_1;
        token[1] = TOKEN_KIND_SUBSCRIPTION;
        crate::crypto::random::read_bytes(&mut token[6..26]);
        token[26..34].copy_from_slice(&issued.to_le_bytes());
        token[34..42].copy_from_slice(&expires.to_le_bytes());
        token[42..75].copy_from_slice(intended_for.address());
        token[75..108].copy_from_slice(issued_by.address());

        let signature = issued_by.sign(&token[0..108]);
        token[108..172].copy_from_slice(&signature);

        Subscription { token }
    }

    pub fn nonce(&self) -> &[u8] {
        &self.token[6..26]
    }

    pub fn issued(&self) -> i64 {
        i64::from_le_bytes(
            self.token[26..34]
                .try_into()
                .expect("invalid issued timestamp"),
        )
    }

    pub fn expires(&self) -> i64 {
        i64::from_le_bytes(
            self.token[34..42]
                .try_into()
                .expect("invalid expires timestamp"),
        )
    }

    pub fn issuer(&self) -> &[u8] {
        &self.token[75..108]
    }

    pub fn bearer(&self) -> &[u8] {
        &self.token[42..75]
    }

    pub fn validate(&self) -> Result<(), SelfError> {
        // validate header size
        if self.token.len() < HEADER_LENGTH {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate timestamps
        let issued = match self.token[26..34].try_into() {
            Ok(issued) => i64::from_le_bytes(issued),
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        let expires = match self.token[34..42].try_into() {
            Ok(expires) => i64::from_le_bytes(expires),
            Err(_) => return Err(SelfError::TokenEncodingInvalid),
        };

        if issued > expires {
            return Err(SelfError::TokenEncodingInvalid);
        }

        if self.token.len() < SUBSCRIBE_BASE_LENGTH {
            return Err(SelfError::TokenEncodingInvalid);
        }

        // validate bearer
        signing::PublicKey::validate(&self.token[42..75])?;

        // validate signer
        let signer = signing::PublicKey::from_bytes(&self.token[75..108])?;

        // validate signature
        if !signer.verify(&self.token[0..108], &self.token[108..172]) {
            return Err(SelfError::TokenSignatureInvalid);
        }

        Ok(())
    }

    pub fn to_vec(&self) -> Vec<u8> {
        self.token.to_vec()
    }

    pub fn as_bytes(&self) -> &[u8] {
        &self.token
    }
}
