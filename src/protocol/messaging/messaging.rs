// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod messaging {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_VERSION: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_VERSION: u8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_VERSION: [Version; 2] = [Version::Unknown, Version::V1];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Version(pub u8);
    #[allow(non_upper_case_globals)]
    impl Version {
        pub const Unknown: Self = Self(0);
        pub const V1: Self = Self(1);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Unknown, Self::V1];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Unknown => Some("Unknown"),
                Self::V1 => Some("V1"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Version {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Version {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Version {
        type Output = Version;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Version {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Version {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Version {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_STATUS_CODE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_STATUS_CODE: u8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_STATUS_CODE: [StatusCode; 2] =
        [StatusCode::BADAUTH, StatusCode::INBOXCLOSED];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct StatusCode(pub u8);
    #[allow(non_upper_case_globals)]
    impl StatusCode {
        pub const BADAUTH: Self = Self(0);
        pub const INBOXCLOSED: Self = Self(1);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::BADAUTH, Self::INBOXCLOSED];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::BADAUTH => Some("BADAUTH"),
                Self::INBOXCLOSED => Some("INBOXCLOSED"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for StatusCode {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for StatusCode {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for StatusCode {
        type Output = StatusCode;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for StatusCode {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for StatusCode {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for StatusCode {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_SIGNATURE_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_SIGNATURE_TYPE: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_SIGNATURE_TYPE: [SignatureType; 2] =
        [SignatureType::PAYLOAD, SignatureType::TOKEN];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct SignatureType(pub i8);
    #[allow(non_upper_case_globals)]
    impl SignatureType {
        pub const PAYLOAD: Self = Self(0);
        pub const TOKEN: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::PAYLOAD, Self::TOKEN];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::PAYLOAD => Some("PAYLOAD"),
                Self::TOKEN => Some("TOKEN"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for SignatureType {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for SignatureType {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for SignatureType {
        type Output = SignatureType;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for SignatureType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = i8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = i8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for SignatureType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for SignatureType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_CONTENT_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_CONTENT_TYPE: i8 = 5;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_CONTENT_TYPE: [ContentType; 6] = [
        ContentType::ACKNOWLEDGEMENT,
        ContentType::ERROR,
        ContentType::SUBSCRIBE,
        ContentType::MESSAGE,
        ContentType::OPEN,
        ContentType::CLOSE,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ContentType(pub i8);
    #[allow(non_upper_case_globals)]
    impl ContentType {
        pub const ACKNOWLEDGEMENT: Self = Self(0);
        pub const ERROR: Self = Self(1);
        pub const SUBSCRIBE: Self = Self(2);
        pub const MESSAGE: Self = Self(3);
        pub const OPEN: Self = Self(4);
        pub const CLOSE: Self = Self(5);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 5;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::ACKNOWLEDGEMENT,
            Self::ERROR,
            Self::SUBSCRIBE,
            Self::MESSAGE,
            Self::OPEN,
            Self::CLOSE,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::ACKNOWLEDGEMENT => Some("ACKNOWLEDGEMENT"),
                Self::ERROR => Some("ERROR"),
                Self::SUBSCRIBE => Some("SUBSCRIBE"),
                Self::MESSAGE => Some("MESSAGE"),
                Self::OPEN => Some("OPEN"),
                Self::CLOSE => Some("CLOSE"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for ContentType {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ContentType {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for ContentType {
        type Output = ContentType;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for ContentType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = i8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = i8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ContentType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ContentType {}
    pub enum SignatureOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Signature<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Signature<'a> {
        type Inner = Signature<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Signature<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Signature { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SignatureArgs<'args>,
        ) -> flatbuffers::WIPOffset<Signature<'bldr>> {
            let mut builder = SignatureBuilder::new(_fbb);
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.signer {
                builder.add_signer(x);
            }
            builder.add_type_(args.type_);
            builder.finish()
        }

        pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
        pub const VT_SIGNER: flatbuffers::VOffsetT = 6;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn type_(&self) -> SignatureType {
            self._tab
                .get::<SignatureType>(Signature::VT_TYPE_, Some(SignatureType::PAYLOAD))
                .unwrap()
        }
        #[inline]
        pub fn signer(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Signature::VT_SIGNER,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn signature(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Signature::VT_SIGNATURE,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for Signature<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<SignatureType>(&"type_", Self::VT_TYPE_, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"signer",
                    Self::VT_SIGNER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SignatureArgs<'a> {
        pub type_: SignatureType,
        pub signer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for SignatureArgs<'a> {
        #[inline]
        fn default() -> Self {
            SignatureArgs {
                type_: SignatureType::PAYLOAD,
                signer: None,
                signature: None,
            }
        }
    }
    pub struct SignatureBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SignatureBuilder<'a, 'b> {
        #[inline]
        pub fn add_type_(&mut self, type_: SignatureType) {
            self.fbb_.push_slot::<SignatureType>(
                Signature::VT_TYPE_,
                type_,
                SignatureType::PAYLOAD,
            );
        }
        #[inline]
        pub fn add_signer(&mut self, signer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Signature::VT_SIGNER, signer);
        }
        #[inline]
        pub fn add_signature(
            &mut self,
            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Signature::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SignatureBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SignatureBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Signature<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Signature<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Signature");
            ds.field("type_", &self.type_());
            ds.field("signer", &self.signer());
            ds.field("signature", &self.signature());
            ds.finish()
        }
    }
    pub enum PayloadOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Payload<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Payload<'a> {
        type Inner = Payload<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Payload<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Payload { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PayloadArgs<'args>,
        ) -> flatbuffers::WIPOffset<Payload<'bldr>> {
            let mut builder = PayloadBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            builder.add_sequence(args.sequence);
            if let Some(x) = args.content {
                builder.add_content(x);
            }
            if let Some(x) = args.recipient {
                builder.add_recipient(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.finish()
        }

        pub const VT_SEQUENCE: flatbuffers::VOffsetT = 4;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;
        pub const VT_SENDER: flatbuffers::VOffsetT = 8;
        pub const VT_RECIPIENT: flatbuffers::VOffsetT = 10;
        pub const VT_CONTENT: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn sequence(&self) -> u64 {
            self._tab.get::<u64>(Payload::VT_SEQUENCE, Some(0)).unwrap()
        }
        #[inline]
        pub fn timestamp(&self) -> i64 {
            self._tab
                .get::<i64>(Payload::VT_TIMESTAMP, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn sender(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Payload::VT_SENDER,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn recipient(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Payload::VT_RECIPIENT,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn content(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Payload::VT_CONTENT,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for Payload<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>(&"sequence", Self::VT_SEQUENCE, false)?
                .visit_field::<i64>(&"timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"sender",
                    Self::VT_SENDER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"recipient",
                    Self::VT_RECIPIENT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"content",
                    Self::VT_CONTENT,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PayloadArgs<'a> {
        pub sequence: u64,
        pub timestamp: i64,
        pub sender: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub recipient: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for PayloadArgs<'a> {
        #[inline]
        fn default() -> Self {
            PayloadArgs {
                sequence: 0,
                timestamp: 0,
                sender: None,
                recipient: None,
                content: None,
            }
        }
    }
    pub struct PayloadBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PayloadBuilder<'a, 'b> {
        #[inline]
        pub fn add_sequence(&mut self, sequence: u64) {
            self.fbb_
                .push_slot::<u64>(Payload::VT_SEQUENCE, sequence, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: i64) {
            self.fbb_
                .push_slot::<i64>(Payload::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Payload::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_recipient(
            &mut self,
            recipient: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Payload::VT_RECIPIENT, recipient);
        }
        #[inline]
        pub fn add_content(
            &mut self,
            content: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Payload::VT_CONTENT, content);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PayloadBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PayloadBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Payload<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Payload<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Payload");
            ds.field("sequence", &self.sequence());
            ds.field("timestamp", &self.timestamp());
            ds.field("sender", &self.sender());
            ds.field("recipient", &self.recipient());
            ds.field("content", &self.content());
            ds.finish()
        }
    }
    pub enum ProofOfWorkOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ProofOfWork<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ProofOfWork<'a> {
        type Inner = ProofOfWork<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ProofOfWork<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ProofOfWork { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ProofOfWorkArgs<'args>,
        ) -> flatbuffers::WIPOffset<ProofOfWork<'bldr>> {
            let mut builder = ProofOfWorkBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            if let Some(x) = args.hash {
                builder.add_hash(x);
            }
            builder.finish()
        }

        pub const VT_HASH: flatbuffers::VOffsetT = 4;
        pub const VT_NONCE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn hash(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    ProofOfWork::VT_HASH,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            self._tab
                .get::<u64>(ProofOfWork::VT_NONCE, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for ProofOfWork<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"hash",
                    Self::VT_HASH,
                    false,
                )?
                .visit_field::<u64>(&"nonce", Self::VT_NONCE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ProofOfWorkArgs<'a> {
        pub hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub nonce: u64,
    }
    impl<'a> Default for ProofOfWorkArgs<'a> {
        #[inline]
        fn default() -> Self {
            ProofOfWorkArgs {
                hash: None,
                nonce: 0,
            }
        }
    }
    pub struct ProofOfWorkBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ProofOfWorkBuilder<'a, 'b> {
        #[inline]
        pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ProofOfWork::VT_HASH, hash);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(ProofOfWork::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ProofOfWorkBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ProofOfWorkBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ProofOfWork<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ProofOfWork<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ProofOfWork");
            ds.field("hash", &self.hash());
            ds.field("nonce", &self.nonce());
            ds.finish()
        }
    }
    pub enum MessageOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Message<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Message<'a> {
        type Inner = Message<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Message<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Message { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MessageArgs<'args>,
        ) -> flatbuffers::WIPOffset<Message<'bldr>> {
            let mut builder = MessageBuilder::new(_fbb);
            if let Some(x) = args.pow {
                builder.add_pow(x);
            }
            if let Some(x) = args.signatures {
                builder.add_signatures(x);
            }
            if let Some(x) = args.payload {
                builder.add_payload(x);
            }
            builder.finish()
        }

        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 4;
        pub const VT_SIGNATURES: flatbuffers::VOffsetT = 6;
        pub const VT_POW: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn payload(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Message::VT_PAYLOAD,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn signatures(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Signature<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Signature>>,
            >>(Message::VT_SIGNATURES, None)
        }
        #[inline]
        pub fn pow(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Message::VT_POW,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for Message<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"payload",
                    Self::VT_PAYLOAD,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Signature>>,
                >>(&"signatures", Self::VT_SIGNATURES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"pow",
                    Self::VT_POW,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MessageArgs<'a> {
        pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub signatures: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Signature<'a>>>,
            >,
        >,
        pub pow: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for MessageArgs<'a> {
        #[inline]
        fn default() -> Self {
            MessageArgs {
                payload: None,
                signatures: None,
                pow: None,
            }
        }
    }
    pub struct MessageBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
        #[inline]
        pub fn add_payload(
            &mut self,
            payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_PAYLOAD, payload);
        }
        #[inline]
        pub fn add_signatures(
            &mut self,
            signatures: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Signature<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_SIGNATURES, signatures);
        }
        #[inline]
        pub fn add_pow(&mut self, pow: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_POW, pow);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MessageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Message<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Message");
            ds.field("payload", &self.payload());
            ds.field("signatures", &self.signatures());
            ds.field("pow", &self.pow());
            ds.finish()
        }
    }
    pub enum AcknowledgementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Acknowledgement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Acknowledgement<'a> {
        type Inner = Acknowledgement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Acknowledgement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Acknowledgement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args AcknowledgementArgs,
        ) -> flatbuffers::WIPOffset<Acknowledgement<'bldr>> {
            let mut builder = AcknowledgementBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for Acknowledgement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct AcknowledgementArgs {}
    impl<'a> Default for AcknowledgementArgs {
        #[inline]
        fn default() -> Self {
            AcknowledgementArgs {}
        }
    }
    pub struct AcknowledgementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AcknowledgementBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> AcknowledgementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AcknowledgementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Acknowledgement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Acknowledgement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Acknowledgement");
            ds.finish()
        }
    }
    pub enum ErrorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Error<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Error<'a> {
        type Inner = Error<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Error<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Error { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ErrorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Error<'bldr>> {
            let mut builder = ErrorBuilder::new(_fbb);
            if let Some(x) = args.error {
                builder.add_error(x);
            }
            builder.add_code(args.code);
            builder.finish()
        }

        pub const VT_CODE: flatbuffers::VOffsetT = 4;
        pub const VT_ERROR: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn code(&self) -> StatusCode {
            self._tab
                .get::<StatusCode>(Error::VT_CODE, Some(StatusCode::BADAUTH))
                .unwrap()
        }
        #[inline]
        pub fn error(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Error::VT_ERROR,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for Error<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<StatusCode>(&"code", Self::VT_CODE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"error",
                    Self::VT_ERROR,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ErrorArgs<'a> {
        pub code: StatusCode,
        pub error: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for ErrorArgs<'a> {
        #[inline]
        fn default() -> Self {
            ErrorArgs {
                code: StatusCode::BADAUTH,
                error: None,
            }
        }
    }
    pub struct ErrorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ErrorBuilder<'a, 'b> {
        #[inline]
        pub fn add_code(&mut self, code: StatusCode) {
            self.fbb_
                .push_slot::<StatusCode>(Error::VT_CODE, code, StatusCode::BADAUTH);
        }
        #[inline]
        pub fn add_error(&mut self, error: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Error::VT_ERROR, error);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ErrorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ErrorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Error<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Error<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Error");
            ds.field("code", &self.code());
            ds.field("error", &self.error());
            ds.finish()
        }
    }
    pub enum SubscriptionDetailsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SubscriptionDetails<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SubscriptionDetails<'a> {
        type Inner = SubscriptionDetails<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> SubscriptionDetails<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SubscriptionDetails { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SubscriptionDetailsArgs<'args>,
        ) -> flatbuffers::WIPOffset<SubscriptionDetails<'bldr>> {
            let mut builder = SubscriptionDetailsBuilder::new(_fbb);
            builder.add_from(args.from);
            builder.add_issued(args.issued);
            if let Some(x) = args.inbox {
                builder.add_inbox(x);
            }
            builder.finish()
        }

        pub const VT_INBOX: flatbuffers::VOffsetT = 4;
        pub const VT_ISSUED: flatbuffers::VOffsetT = 6;
        pub const VT_FROM: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn inbox(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    SubscriptionDetails::VT_INBOX,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn issued(&self) -> i64 {
            self._tab
                .get::<i64>(SubscriptionDetails::VT_ISSUED, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn from(&self) -> i64 {
            self._tab
                .get::<i64>(SubscriptionDetails::VT_FROM, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for SubscriptionDetails<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"inbox",
                    Self::VT_INBOX,
                    false,
                )?
                .visit_field::<i64>(&"issued", Self::VT_ISSUED, false)?
                .visit_field::<i64>(&"from", Self::VT_FROM, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SubscriptionDetailsArgs<'a> {
        pub inbox: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub issued: i64,
        pub from: i64,
    }
    impl<'a> Default for SubscriptionDetailsArgs<'a> {
        #[inline]
        fn default() -> Self {
            SubscriptionDetailsArgs {
                inbox: None,
                issued: 0,
                from: 0,
            }
        }
    }
    pub struct SubscriptionDetailsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SubscriptionDetailsBuilder<'a, 'b> {
        #[inline]
        pub fn add_inbox(&mut self, inbox: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubscriptionDetails::VT_INBOX,
                inbox,
            );
        }
        #[inline]
        pub fn add_issued(&mut self, issued: i64) {
            self.fbb_
                .push_slot::<i64>(SubscriptionDetails::VT_ISSUED, issued, 0);
        }
        #[inline]
        pub fn add_from(&mut self, from: i64) {
            self.fbb_
                .push_slot::<i64>(SubscriptionDetails::VT_FROM, from, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SubscriptionDetailsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SubscriptionDetailsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SubscriptionDetails<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for SubscriptionDetails<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("SubscriptionDetails");
            ds.field("inbox", &self.inbox());
            ds.field("issued", &self.issued());
            ds.field("from", &self.from());
            ds.finish()
        }
    }
    pub enum SubscriptionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Subscription<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Subscription<'a> {
        type Inner = Subscription<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Subscription<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Subscription { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SubscriptionArgs<'args>,
        ) -> flatbuffers::WIPOffset<Subscription<'bldr>> {
            let mut builder = SubscriptionBuilder::new(_fbb);
            if let Some(x) = args.signatures {
                builder.add_signatures(x);
            }
            if let Some(x) = args.details {
                builder.add_details(x);
            }
            builder.finish()
        }

        pub const VT_DETAILS: flatbuffers::VOffsetT = 4;
        pub const VT_SIGNATURES: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn details(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Subscription::VT_DETAILS,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn signatures(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Signature<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Signature>>,
            >>(Subscription::VT_SIGNATURES, None)
        }
    }

    impl flatbuffers::Verifiable for Subscription<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"details",
                    Self::VT_DETAILS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Signature>>,
                >>(&"signatures", Self::VT_SIGNATURES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SubscriptionArgs<'a> {
        pub details: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub signatures: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Signature<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SubscriptionArgs<'a> {
        #[inline]
        fn default() -> Self {
            SubscriptionArgs {
                details: None,
                signatures: None,
            }
        }
    }
    pub struct SubscriptionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SubscriptionBuilder<'a, 'b> {
        #[inline]
        pub fn add_details(
            &mut self,
            details: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Subscription::VT_DETAILS, details);
        }
        #[inline]
        pub fn add_signatures(
            &mut self,
            signatures: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Signature<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Subscription::VT_SIGNATURES,
                signatures,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SubscriptionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SubscriptionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Subscription<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Subscription<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Subscription");
            ds.field("details", &self.details());
            ds.field("signatures", &self.signatures());
            ds.finish()
        }
    }
    pub enum SubscribeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Subscribe<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Subscribe<'a> {
        type Inner = Subscribe<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Subscribe<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Subscribe { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SubscribeArgs<'args>,
        ) -> flatbuffers::WIPOffset<Subscribe<'bldr>> {
            let mut builder = SubscribeBuilder::new(_fbb);
            if let Some(x) = args.subscriptions {
                builder.add_subscriptions(x);
            }
            builder.finish()
        }

        pub const VT_SUBSCRIPTIONS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn subscriptions(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Subscription<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Subscription>>,
            >>(Subscribe::VT_SUBSCRIPTIONS, None)
        }
    }

    impl flatbuffers::Verifiable for Subscribe<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Subscription>>,
                >>(&"subscriptions", Self::VT_SUBSCRIPTIONS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SubscribeArgs<'a> {
        pub subscriptions: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Subscription<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SubscribeArgs<'a> {
        #[inline]
        fn default() -> Self {
            SubscribeArgs {
                subscriptions: None,
            }
        }
    }
    pub struct SubscribeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SubscribeBuilder<'a, 'b> {
        #[inline]
        pub fn add_subscriptions(
            &mut self,
            subscriptions: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Subscription<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Subscribe::VT_SUBSCRIPTIONS,
                subscriptions,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubscribeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SubscribeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Subscribe<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Subscribe<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Subscribe");
            ds.field("subscriptions", &self.subscriptions());
            ds.finish()
        }
    }
    pub enum OpenDetailsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct OpenDetails<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for OpenDetails<'a> {
        type Inner = OpenDetails<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> OpenDetails<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            OpenDetails { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OpenDetailsArgs<'args>,
        ) -> flatbuffers::WIPOffset<OpenDetails<'bldr>> {
            let mut builder = OpenDetailsBuilder::new(_fbb);
            builder.add_issued(args.issued);
            if let Some(x) = args.nonce {
                builder.add_nonce(x);
            }
            if let Some(x) = args.inbox {
                builder.add_inbox(x);
            }
            builder.finish()
        }

        pub const VT_INBOX: flatbuffers::VOffsetT = 4;
        pub const VT_NONCE: flatbuffers::VOffsetT = 6;
        pub const VT_ISSUED: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn inbox(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    OpenDetails::VT_INBOX,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn nonce(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    OpenDetails::VT_NONCE,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn issued(&self) -> i64 {
            self._tab
                .get::<i64>(OpenDetails::VT_ISSUED, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for OpenDetails<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"inbox",
                    Self::VT_INBOX,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"nonce",
                    Self::VT_NONCE,
                    false,
                )?
                .visit_field::<i64>(&"issued", Self::VT_ISSUED, false)?
                .finish();
            Ok(())
        }
    }
    pub struct OpenDetailsArgs<'a> {
        pub inbox: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub nonce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub issued: i64,
    }
    impl<'a> Default for OpenDetailsArgs<'a> {
        #[inline]
        fn default() -> Self {
            OpenDetailsArgs {
                inbox: None,
                nonce: None,
                issued: 0,
            }
        }
    }
    pub struct OpenDetailsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OpenDetailsBuilder<'a, 'b> {
        #[inline]
        pub fn add_inbox(&mut self, inbox: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(OpenDetails::VT_INBOX, inbox);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(OpenDetails::VT_NONCE, nonce);
        }
        #[inline]
        pub fn add_issued(&mut self, issued: i64) {
            self.fbb_
                .push_slot::<i64>(OpenDetails::VT_ISSUED, issued, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OpenDetailsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OpenDetailsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<OpenDetails<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for OpenDetails<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("OpenDetails");
            ds.field("inbox", &self.inbox());
            ds.field("nonce", &self.nonce());
            ds.field("issued", &self.issued());
            ds.finish()
        }
    }
    pub enum OpenOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Open<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Open<'a> {
        type Inner = Open<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Open<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Open { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OpenArgs<'args>,
        ) -> flatbuffers::WIPOffset<Open<'bldr>> {
            let mut builder = OpenBuilder::new(_fbb);
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.pow {
                builder.add_pow(x);
            }
            if let Some(x) = args.details {
                builder.add_details(x);
            }
            builder.finish()
        }

        pub const VT_DETAILS: flatbuffers::VOffsetT = 4;
        pub const VT_POW: flatbuffers::VOffsetT = 6;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn details(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Open::VT_DETAILS,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn pow(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Open::VT_POW,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn signature(&self) -> Option<Signature<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Signature>>(Open::VT_SIGNATURE, None)
        }
    }

    impl flatbuffers::Verifiable for Open<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"details",
                    Self::VT_DETAILS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"pow",
                    Self::VT_POW,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Signature>>(
                    &"signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct OpenArgs<'a> {
        pub details: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub pow: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub signature: Option<flatbuffers::WIPOffset<Signature<'a>>>,
    }
    impl<'a> Default for OpenArgs<'a> {
        #[inline]
        fn default() -> Self {
            OpenArgs {
                details: None,
                pow: None,
                signature: None,
            }
        }
    }
    pub struct OpenBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OpenBuilder<'a, 'b> {
        #[inline]
        pub fn add_details(
            &mut self,
            details: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Open::VT_DETAILS, details);
        }
        #[inline]
        pub fn add_pow(&mut self, pow: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Open::VT_POW, pow);
        }
        #[inline]
        pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<Signature<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Signature>>(
                    Open::VT_SIGNATURE,
                    signature,
                );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OpenBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OpenBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Open<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Open<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Open");
            ds.field("details", &self.details());
            ds.field("pow", &self.pow());
            ds.field("signature", &self.signature());
            ds.finish()
        }
    }
    pub enum CloseDetailsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CloseDetails<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CloseDetails<'a> {
        type Inner = CloseDetails<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> CloseDetails<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CloseDetails { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CloseDetailsArgs<'args>,
        ) -> flatbuffers::WIPOffset<CloseDetails<'bldr>> {
            let mut builder = CloseDetailsBuilder::new(_fbb);
            builder.add_issued(args.issued);
            if let Some(x) = args.inbox {
                builder.add_inbox(x);
            }
            builder.finish()
        }

        pub const VT_INBOX: flatbuffers::VOffsetT = 4;
        pub const VT_ISSUED: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn inbox(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    CloseDetails::VT_INBOX,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn issued(&self) -> i64 {
            self._tab
                .get::<i64>(CloseDetails::VT_ISSUED, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for CloseDetails<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"inbox",
                    Self::VT_INBOX,
                    false,
                )?
                .visit_field::<i64>(&"issued", Self::VT_ISSUED, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CloseDetailsArgs<'a> {
        pub inbox: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub issued: i64,
    }
    impl<'a> Default for CloseDetailsArgs<'a> {
        #[inline]
        fn default() -> Self {
            CloseDetailsArgs {
                inbox: None,
                issued: 0,
            }
        }
    }
    pub struct CloseDetailsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CloseDetailsBuilder<'a, 'b> {
        #[inline]
        pub fn add_inbox(&mut self, inbox: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CloseDetails::VT_INBOX, inbox);
        }
        #[inline]
        pub fn add_issued(&mut self, issued: i64) {
            self.fbb_
                .push_slot::<i64>(CloseDetails::VT_ISSUED, issued, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CloseDetailsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CloseDetailsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CloseDetails<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for CloseDetails<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("CloseDetails");
            ds.field("inbox", &self.inbox());
            ds.field("issued", &self.issued());
            ds.finish()
        }
    }
    pub enum CloseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Close<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Close<'a> {
        type Inner = Close<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Close<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Close { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CloseArgs<'args>,
        ) -> flatbuffers::WIPOffset<Close<'bldr>> {
            let mut builder = CloseBuilder::new(_fbb);
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.details {
                builder.add_details(x);
            }
            builder.finish()
        }

        pub const VT_DETAILS: flatbuffers::VOffsetT = 4;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn details(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Close::VT_DETAILS,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn signature(&self) -> Option<Signature<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Signature>>(Close::VT_SIGNATURE, None)
        }
    }

    impl flatbuffers::Verifiable for Close<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"details",
                    Self::VT_DETAILS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Signature>>(
                    &"signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct CloseArgs<'a> {
        pub details: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub signature: Option<flatbuffers::WIPOffset<Signature<'a>>>,
    }
    impl<'a> Default for CloseArgs<'a> {
        #[inline]
        fn default() -> Self {
            CloseArgs {
                details: None,
                signature: None,
            }
        }
    }
    pub struct CloseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CloseBuilder<'a, 'b> {
        #[inline]
        pub fn add_details(
            &mut self,
            details: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Close::VT_DETAILS, details);
        }
        #[inline]
        pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<Signature<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Signature>>(
                    Close::VT_SIGNATURE,
                    signature,
                );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CloseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CloseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Close<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Close<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Close");
            ds.field("details", &self.details());
            ds.field("signature", &self.signature());
            ds.finish()
        }
    }
    pub enum EventOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Event<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Event<'a> {
        type Inner = Event<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Event<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Event { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args EventArgs<'args>,
        ) -> flatbuffers::WIPOffset<Event<'bldr>> {
            let mut builder = EventBuilder::new(_fbb);
            if let Some(x) = args.content {
                builder.add_content(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.add_type_(args.type_);
            builder.add_version(args.version);
            builder.finish()
        }

        pub const VT_VERSION: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
        pub const VT_CONTENT: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn version(&self) -> Version {
            self._tab
                .get::<Version>(Event::VT_VERSION, Some(Version::Unknown))
                .unwrap()
        }
        #[inline]
        pub fn id(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Event::VT_ID,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn type_(&self) -> ContentType {
            self._tab
                .get::<ContentType>(Event::VT_TYPE_, Some(ContentType::ACKNOWLEDGEMENT))
                .unwrap()
        }
        #[inline]
        pub fn content(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Event::VT_CONTENT,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for Event<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Version>(&"version", Self::VT_VERSION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"id",
                    Self::VT_ID,
                    false,
                )?
                .visit_field::<ContentType>(&"type_", Self::VT_TYPE_, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"content",
                    Self::VT_CONTENT,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct EventArgs<'a> {
        pub version: Version,
        pub id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub type_: ContentType,
        pub content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for EventArgs<'a> {
        #[inline]
        fn default() -> Self {
            EventArgs {
                version: Version::Unknown,
                id: None,
                type_: ContentType::ACKNOWLEDGEMENT,
                content: None,
            }
        }
    }
    pub struct EventBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> EventBuilder<'a, 'b> {
        #[inline]
        pub fn add_version(&mut self, version: Version) {
            self.fbb_
                .push_slot::<Version>(Event::VT_VERSION, version, Version::Unknown);
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_ID, id);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: ContentType) {
            self.fbb_.push_slot::<ContentType>(
                Event::VT_TYPE_,
                type_,
                ContentType::ACKNOWLEDGEMENT,
            );
        }
        #[inline]
        pub fn add_content(
            &mut self,
            content: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_CONTENT, content);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EventBuilder<'a, 'b> {
            let start = _fbb.start_table();
            EventBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Event<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Event<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Event");
            ds.field("version", &self.version());
            ds.field("id", &self.id());
            ds.field("type_", &self.type_());
            ds.field("content", &self.content());
            ds.finish()
        }
    }
    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_root_as_event<'a>(buf: &'a [u8]) -> Event<'a> {
        unsafe { flatbuffers::root_unchecked::<Event<'a>>(buf) }
    }

    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_size_prefixed_root_as_event<'a>(buf: &'a [u8]) -> Event<'a> {
        unsafe { flatbuffers::size_prefixed_root_unchecked::<Event<'a>>(buf) }
    }

    #[inline]
    /// Verifies that a buffer of bytes contains a `Event`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_event_unchecked`.
    pub fn root_as_event(buf: &[u8]) -> Result<Event, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Event>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Event` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_event_unchecked`.
    pub fn size_prefixed_root_as_event(
        buf: &[u8],
    ) -> Result<Event, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Event>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Event` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_event_unchecked`.
    pub fn root_as_event_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Event<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Event<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Event` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_event_unchecked`.
    pub fn size_prefixed_root_as_event_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Event<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Event<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Event and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Event`.
    pub unsafe fn root_as_event_unchecked(buf: &[u8]) -> Event {
        flatbuffers::root_unchecked::<Event>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Event and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Event`.
    pub unsafe fn size_prefixed_root_as_event_unchecked(buf: &[u8]) -> Event {
        flatbuffers::size_prefixed_root_unchecked::<Event>(buf)
    }
    #[inline]
    pub fn finish_event_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Event<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_event_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Event<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod messaging
